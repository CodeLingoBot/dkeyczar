
High Priority:

    - implement keyczar tool so our library is standalone
        => other export options (cert? pkcs8/pkcs5? ...?)

    - key.ID()
    - key.IsAcceptablePurpose(purpose) / key.Purpose() { return KpPURPOSE } ?
    - key.Type() => ktFOO constant

    - improve internal documentation (keydata)

    - PKCS#8 private key import/export
      -- asn1 is painful.
      (dsa not supported -- must implement)
      (rsa export not supported -- must implement)

Low Priority:

    - write code to generate c++ test case for compatibility
    - keyIDer is a bad name
    - some of the ImportFOOForBar would be easier if we exported the KeyPurpose enum
    - newKeysFromJSON is actually newKeysFromReader and probably belongs in keyczar.go
    - fix keymeta.Versions so Versions[versionNumber] is correct (placeholder? nil?)

    - write functions to abstract byte-stream format
        getIv()
        getCipherText()
        getSignature()
    - try not to modify slices
    - refactor marshaljson quoted string creation ?
    - better error messages?  "bad version 0x4 in header" vs. "bad version in header"
    - string -> []byte changes for API?
    - signed session encryption
        => not sure if this is actually useful.  either you have a shared secret, or you don't.

    - test cases for
        encodeWeb64String
        decodeWeb64String
        lenPrefixPack
        lenPrefixUnpack

    - cache key id so it's only calculated once at key load time?
    - timed signatures
    - unversioned signatures
    - for pbereader, don't store password, only hmac? (and let it store the password?0
    - pbkdf2 should take hash.Hash instead of password? (generalize?)
    - code reorg
        split keydata into aeskey, rsakey, ... ?
